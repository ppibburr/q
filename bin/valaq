#!/usr/bin/env ruby
require 'optparse'
ARGV << '-h' if ARGV.empty? or ARGV[0] =~ /^\-/

options = {:valac=>'valac', :verbose => false, :compile => true}
optparse = OptionParser.new do |opts|
  opts.banner = "Q Compiler\n\nUsage: valaq file [options] [-- [valac_options]]"
  opts.separator ""
  opts.on("-v", "--[no-]verbose", "Run verbosely") do |v|
    options[:verbose] = v
  end
  
  opts.on("--introspection NAMESPACE-VERSION", "generate a gir: <NAMESPACE>-<VERSION>.gir") do |v|
    options[:gir] = v
  end
  
  opts.on("--[no-]compile", "compiles") do |v|
    options[:compile] = v
  end  
  
  opts.on("--[no-]remove-generated", "Removes generated .vala files") do |v|
    options[:remove] = v
  end
  
  opts.on("-V", "--valac VALAC", "specify the valac command") do |v|
    options[:valac] = v
  end
  
  opts.on("-e", "--exec", "execute after compiling") do
    options[:exec] = true
  end   
  
  opts.on( "--version", "show the version") do
    options[:version] = true
  end 
  
  opts.on("-h", "--help", "Displays this summary" ) do
    puts opts
    exit(1)
  end
  
  opts.separator ""
  opts.separator "For valac options run 'valac --help'." 
  opts.separator ""   
end

arguments = ARGV.dup
secondary_arguments = []

first_run = true
errors = false
while errors || first_run
  errors = false
  first_run = false
  begin
    optparse.order!(arguments) do |unrecognized_option|
      secondary_arguments.push(unrecognized_option)
    end
  rescue OptionParser::InvalidOption => e
    errors = true
    e.args.each { |arg| secondary_arguments.push(arg) }
    arguments.delete(e.args)
  end
end

primary_arguments = ARGV.dup
secondary_arguments.each do |cuke_arg|
  primary_arguments.delete(cuke_arg)
end

optparse.parse(primary_arguments)

if !options.has_key?(:remove)
  options[:remove] = true
end

if options[:verbose]
  secondary_arguments << "-v"
end

require 'q'
require "q/builder/compilers/vala.rb"

def vala_file f
  base = File.basename(f)
  dir  = File.dirname(f)
  File.join(dir,"#{base.gsub(/\.q$/,".vala")}")
end
COMMENTS = {}
def perform f, reqs=[]
  reqs << f unless reqs.index f

  code = open(f).read
  ast = Q.build(code, f)

  ast.parented nil
  COMMENTS[f] = Q::COMMENTS.dup;
  Q::COMMENTS.clear
  ast.requires.each do |req|
    if req.ok?
	  perform req.path, reqs	
    else
  	  puts "RequireError: #{req.source} - #{req.line}, no such file: #{req.path}"
  	  exit 1
	end
  end  

  Q::COMMENTS.clear
  Q::COMMENTS.push *COMMENTS[f]
  File.open(vala_file(f), "w") do |f| f.puts Q::ValaSourceGenerator.new(ast).compile end
end

f = File.expand_path(secondary_arguments.shift)
REL_DIR = File.dirname(f)
perform f, reqs = []

if options[:gir]
  secondary_arguments.insert(0, "--gir=#{options[:gir]}.gir --library #{options[:gir]} -o lib#{options[:gir].split("-")[0].downcase}.so")
end

if options[:compile]
  puts cmd="valac #{vs=reqs.uniq.map do |f| vala_file(f) end.join(" ")} #{secondary_arguments.join(" ")}#{options[:gir] ? " -X -fPIC -X -shared" : ""}".strip
  system cmd
  system "rm #{vs}" if options[:remove]
  if options[:gir]
    puts cmd = "mkdir -p ./q-gir/usr/lib/girepository-1.0 ./q-gir/usr/share/gir-1.0 ./q-gir/usr/share/vala-#{z=`valac --version`.strip.split(" ")[1].split(".")[0..1].join(".")}"
    system cmd
    puts cmd = "g-ir-compiler --shared-library=#{q=options[:gir].split("-")[0].downcase} #{options[:gir]}.gir -o #{options[:gir]}.typelib" 
    system cmd
    system "mv #{options[:gir]}.typelib ./q-gir/usr/lib/girepository-1.0/"
    system "mv #{options[:gir]}.gir ./q-gir/usr/share/gir-1.0/"
    system "mv ./lib#{q}.so ./q-gir/usr/lib/"
    system "mv #{options[:gir]}.vapi ./q-gir/usr/share/vala-#{z}/"
    File.open("test_#{q}_gir.rb", "w") do |f|
      f.puts <<-EOC
begin
  require 'gir_ffi'
rescue
  require 'rubygems'
  require 'gir_ffi'
end

GirFFI.setup '#{options[:gir].split("-")[0]}', '#{options[:gir].split("-")[1]}'
p #{options[:gir].split("-")[0]}
      EOC
    end 
  end
  if options[:exec]
    system "./#{File.basename(f.gsub(/\.q$/,''))}"
  end
end
